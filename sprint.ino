#include <Dynamixel2Arduino.h>
#include <vector>
#define DXL_SERIAL Serial3 //définit le type de bus pour la communication avec les servos
#define DEBUG_SERIAL Serial

//const uint8_t OLD_ID = 15;
//const uint8_t NEW_ID = 1;

const int DXL_DIR_PIN = 22;
const float DXL_PROTOCOL_VERSION = 1.0;
uint32_t BAUDRATE = 1000000;

float ax12_2_deg(uint16_t X) 
{
  float flottant = ((X * 150 / 512) - 150);
  return flottant;
}

uint16_t deg_2_ax12(float X)  //ou int deg2_2_ax12
{
  uint16_t entier = round((((X + 150) * 512) / 150));
  return entier;
}

std::vector<float> Offset{0, 0, -90, 0, 0, 0, 90, 0, -90, 90, 0, -90};

Dynamixel2Arduino dxl(DXL_SERIAL, DXL_DIR_PIN);

//COMMANDE D'ANGLES AUX MOTEURS POUR LA TRANSLATION
void setcoordT(const std::vector<float>& Q) {
    dxl.setGoalPosition(1,deg_2_ax12(Q[0]+Offset[0])); //-45+Q[0]+Offset[0]
    dxl.setGoalPosition(10,deg_2_ax12(-Q[0]+Offset[9])); //-45-Q[0]+Offset[9]
    dxl.setGoalPosition(2,deg_2_ax12(Q[1]+Offset[1]));
    dxl.setGoalPosition(11,deg_2_ax12(Q[1]+Offset[10]));
    dxl.setGoalPosition(3,deg_2_ax12(-90-Q[1]+Offset[2]));
    dxl.setGoalPosition(12,deg_2_ax12(-90-Q[1]+Offset[11]));
    dxl.setGoalPosition(4,deg_2_ax12(Q[2]+Offset[3])); //45+Q[2]+Offset[3]
    dxl.setGoalPosition(7,deg_2_ax12(-Q[2]+Offset[6])); //45-Q[2]+Offset[6]
    dxl.setGoalPosition(5,deg_2_ax12(Q[3]+Offset[4]));
    dxl.setGoalPosition(8,deg_2_ax12(Q[3]+Offset[7]));
    dxl.setGoalPosition(6,deg_2_ax12(-90-Q[3]+Offset[5]));
    dxl.setGoalPosition(9,deg_2_ax12(-90-Q[3]+Offset[8]));
}


//LISTE DE COORDONNEES OPERATIONNELLES à copier/coller depuis un .txt
//std::vector<float> PosIni{0, 90, -90, 0, -90, 0, 90, -90, -90, 90, -90, -90}; //pour mettre le robot debout
std::vector<float> PosIni{0, -90, 0, -90};


std::vector<std::vector<float>> qR2 = {{-9.17,-66.17,-9.17,-65.56},
{-5.73,-66.13,-9.17,-62.12},
{-2.29,-66.13,-9.17,-58.68},
{1.15,-66.13,-9.17,-55.25},
{4.58,-66.13,-9.17,-51.81},
{8.02,-66.13,-9.17,-48.37},
{9.17,-66.13,-9.17,-44.93},
{9.17,-66.13,-9.17,-41.49},
{9.17,-66.13,-9.17,-38.06},
{9.17,-66.13,-9.17,-34.62},
{9.17,-66.13,-9.17,-31.18},
{9.17,-66.13,-9.17,-27.74},
{9.17,-66.13,-9.17,-24.31},
{9.17,-66.13,-9.17,-20.87},
{9.17,-66.13,-9.17,-17.43},
{9.17,-66.13,-9.17,-13.99},
{9.17,-66.13,-9.17,-10.55},
{9.17,-66.13,-8.02,-9.41},
{9.17,-66.13,-4.58,-12.85},
{9.17,-66.13,-1.15,-16.28},
{9.17,-66.13,2.29,-19.72},
{9.17,-66.13,5.73,-23.16},
{9.17,-66.13,9.17,-26.6},
{9.17,-66.13,9.17,-30.04},
{9.17,-66.13,9.17,-33.47},
{9.17,-66.13,9.17,-36.91},
{9.17,-66.13,9.17,-40.35},
{9.17,-66.13,9.17,-43.79},
{9.17,-66.13,9.17,-47.22},
{9.17,-66.13,9.17,-50.66},
{9.17,-66.13,9.17,-54.1},
{9.17,-66.13,9.17,-57.54},
{9.17,-66.13,9.17,-60.98},
{9.17,-66.13,9.17,-64.41},
{9.17,-64.41,7.45,-66.13},
{9.17,-60.98,4.01,-66.13},
{9.17,-57.54,0.57,-66.13},
{9.17,-54.1,-2.86,-66.13},
{9.17,-50.66,-6.3,-66.13},
{9.17,-47.22,-9.17,-66.13},
{9.17,-43.79,-9.17,-66.13},
{9.17,-40.35,-9.17,-66.13},
{9.17,-36.91,-9.17,-66.13},
{9.17,-33.47,-9.17,-66.13},
{9.17,-30.04,-9.17,-66.13},
{9.17,-26.6,-9.17,-66.13},
{9.17,-23.16,-9.17,-66.13},
{9.17,-19.72,-9.17,-66.13},
{9.17,-16.28,-9.17,-66.13},
{9.17,-12.85,-9.17,-66.13},
{9.17,-9.41,-9.17,-66.13},
{6.88,-10.55,-9.17,-66.13},
{3.44,-13.99,-9.17,-66.13},
{-0.0,-17.43,-9.17,-66.13},
{-3.44,-20.87,-9.17,-66.13},
{-6.88,-24.31,-9.17,-66.13},
{-9.17,-27.74,-9.17,-66.13},
{-9.17,-31.18,-9.17,-66.13},
{-9.17,-34.62,-9.17,-66.13},
{-9.17,-38.06,-9.17,-66.13},
{-9.17,-41.49,-9.17,-66.13},
{-9.17,-44.93,-9.17,-66.13},
{-9.17,-48.37,-9.17,-66.13},
{-9.17,-51.81,-9.17,-66.13},
{-9.17,-55.25,-9.17,-66.13},
{-9.17,-58.68,-9.17,-66.13},
{-9.17,-62.12,-9.17,-66.13},
{-9.17,-65.56,-9.17,-66.13}};

/*
std::vector <std::vector <float>> qR2 = {{-14.32,-66.17,-14.32,-65.56},
{-10.89,-66.13,-14.32,-62.12},
{-7.45,-66.13,-14.32,-58.68},
{-4.01,-66.13,-14.32,-55.25},
{-0.57,-66.13,-14.32,-51.81},
{2.86,-66.13,-14.32,-48.37},
{6.3,-66.13,-14.32,-44.93},
{9.74,-66.13,-14.32,-41.49},
{13.18,-66.13,-14.32,-38.06},
{14.32,-66.13,-14.32,-34.62},
{14.32,-66.13,-14.32,-31.18},
{14.32,-66.13,-14.32,-27.74},
{14.32,-66.13,-14.32,-24.31},
{14.32,-66.13,-14.32,-20.87},
{14.32,-66.13,-14.32,-17.43},
{14.32,-66.13,-14.32,-13.99},
{14.32,-66.13,-14.32,-10.55},
{14.32,-66.13,-13.18,-9.41},
{14.32,-66.13,-9.74,-12.85},
{14.32,-66.13,-6.3,-16.28},
{14.32,-66.13,-2.86,-19.72},
{14.32,-66.13,0.57,-23.16},
{14.32,-66.13,4.01,-26.6},
{14.32,-66.13,7.45,-30.04},
{14.32,-66.13,10.89,-33.47},
{14.32,-66.13,14.32,-36.91},
{14.32,-66.13,14.32,-40.35},
{14.32,-66.13,14.32,-43.79},
{14.32,-66.13,14.32,-47.22},
{14.32,-66.13,14.32,-50.66},
{14.32,-66.13,14.32,-54.1},
{14.32,-66.13,14.32,-57.54},
{14.32,-66.13,14.32,-60.98},
{14.32,-66.13,14.32,-64.41},
{14.32,-64.41,12.61,-66.13},
{14.32,-60.98,9.17,-66.13},
{14.32,-57.54,5.73,-66.13},
{14.32,-54.1,2.29,-66.13},
{14.32,-50.66,-1.15,-66.13},
{14.32,-47.22,-4.58,-66.13},
{14.32,-43.79,-8.02,-66.13},
{14.32,-40.35,-11.46,-66.13},
{14.32,-36.91,-14.32,-66.13},
{14.32,-33.47,-14.32,-66.13},
{14.32,-30.04,-14.32,-66.13},
{14.32,-26.6,-14.32,-66.13},
{14.32,-23.16,-14.32,-66.13},
{14.32,-19.72,-14.32,-66.13},
{14.32,-16.28,-14.32,-66.13},
{14.32,-12.85,-14.32,-66.13},
{14.32,-9.41,-14.32,-66.13},
{12.03,-10.55,-14.32,-66.13},
{8.59,-13.99,-14.32,-66.13},
{5.16,-17.43,-14.32,-66.13},
{1.72,-20.87,-14.32,-66.13},
{-1.72,-24.31,-14.32,-66.13},
{-5.16,-27.74,-14.32,-66.13},
{-8.59,-31.18,-14.32,-66.13},
{-12.03,-34.62,-14.32,-66.13},
{-14.32,-38.06,-14.32,-66.13},
{-14.32,-41.49,-14.32,-66.13},
{-14.32,-44.93,-14.32,-66.13},
{-14.32,-48.37,-14.32,-66.13},
{-14.32,-51.81,-14.32,-66.13},
{-14.32,-55.25,-14.32,-66.13},
{-14.32,-58.68,-14.32,-66.13},
{-14.32,-62.12,-14.32,-66.13},
{-14.32,-65.56,-14.32,-66.13}}
;

*/


void Avancer(){
  for (const auto& element : qR2)
  {
    setcoordT(element);
    delay(3);
  }
}

void Reculer(){
  for (int i=0; i<qR2.size(); i++)
  {
    setcoordT(qR2[qR2.size()-i-1]);
    delay(3);
  }
}



void setup() 
{
  dxl.begin(BAUDRATE); // on initialise la communication avec le moteur par la définition du baudrate
  dxl.setPortProtocolVersion(DXL_PROTOCOL_VERSION); // on déclare le protocole de communication

  for (int i{1}; i<13; i++)
  {
    dxl.torqueOff(i);
    dxl.setOperatingMode(i,OP_POSITION);
    //dxl.writeControlTableItem(ControlTableItem::MOVING_SPEED, i, 0); ne contrôle rien
    dxl.torqueOn(i);
    //Offset.push_back(ax12_2_deg(dxl.getPresentPosition(i)));
  }

  for (int i{1}; i<13; i++)
  {
    dxl.setGoalPosition(i,deg_2_ax12(Offset[i-1]));;
  }
  
  delay(2000);
  

//Levage du robot
  setcoordR(PosIni);
  delay(2000);
  /*
  setcoordT(qR2[0]);
  delay(1000);
  */

  
  for (int i{0}; i<54; i++) //pour EMC25
  {
    Avancer();
  }
  

  /* Faire un carré !
 for (int i{1}; i<5; i++)
 {
 setcoordR(PosIni);
 delay(500);
 Avancer();
 Avancer();
 setcoordR(PosIni);
 delay(500);
 RotationP90();
 //delay(500);
 }
 setcoordR(PosIni);
 */
  
}

void loop() {
  /*
  RotationP90();
   RotationP90();
  for (int i{0}; i<4; i++) //pour EMC25
  {
    Avancer();
  }
  RotationP90();
  */
} 
